-- Virtual text annotations for DSL entity files.
-- Shows type descriptions above fields and term descriptions after values.
-- Reads dsl/hints.lua (generated by dsl/check.lua) from the project root.
-- Toggle: <leader>td or :DslHintsToggle

local ns = vim.api.nvim_create_namespace 'dsl-hints'
local hints_cache = {}
local enabled = false

local function load_hints(root)
  local path = root .. '/dsl/hints.lua'
  local stat = vim.uv.fs_stat(path)
  if not stat then
    hints_cache[root] = nil
    return nil
  end

  local cached = hints_cache[root]
  if cached and cached.mtime == stat.mtime.sec then
    return cached.hints
  end

  local fn = loadfile(path)
  if fn then
    local ok, result = pcall(fn)
    if ok then
      hints_cache[root] = { hints = result, mtime = stat.mtime.sec }
      return result
    end
  end

  hints_cache[root] = nil
  return nil
end

--- Recursively find string nodes and annotate them with term descriptions.
local function annotate_strings(node, hints, bufnr)
  if node:type() == 'string' then
    for child in node:iter_children() do
      if child:type() == 'string_content' then
        local text = vim.treesitter.get_node_text(child, bufnr)
        local desc = hints.terms[text]
        if desc then
          local line = node:start()
          vim.api.nvim_buf_set_extmark(bufnr, ns, line, 0, {
            virt_text = { { '  -- ' .. desc, 'Comment' } },
            virt_text_pos = 'eol',
          })
        end
        break
      end
    end
    return
  end
  for child in node:iter_children() do
    annotate_strings(child, hints, bufnr)
  end
end

--- Walk treesitter nodes looking for type-reference fields to annotate.
local function walk(node, hints, bufnr)
  if node:type() == 'field' then
    local name_node = node:field('name')[1]
    local value_node = node:field('value')[1]
    if name_node and value_node then
      local field_name = vim.treesitter.get_node_text(name_node, bufnr)
      local desc = hints.fields[field_name]
      if desc then
        -- Type description above the field line
        local line = node:start()
        local line_text = vim.api.nvim_buf_get_lines(bufnr, line, line + 1, false)[1] or ''
        local indent = line_text:match '^(%s*)' or ''
        vim.api.nvim_buf_set_extmark(bufnr, ns, line, 0, {
          virt_lines_above = true,
          virt_lines = { { { indent .. '-- ' .. desc, 'Comment' } } },
        })
        -- Term descriptions after each string value
        annotate_strings(value_node, hints, bufnr)
        return
      end
    end
  end

  for child in node:iter_children() do
    walk(child, hints, bufnr)
  end
end

local function refresh(bufnr)
  vim.api.nvim_buf_clear_namespace(bufnr, ns, 0, -1)

  if not enabled then
    return
  end

  local first_line = vim.api.nvim_buf_get_lines(bufnr, 0, 1, false)[1] or ''
  if not first_line:match 'Dsl' then
    return
  end

  local root = vim.fs.root(bufnr, { '.git', '.luarc.json' })
  if not root then
    return
  end

  local hints = load_hints(root)
  if not hints then
    return
  end

  local parser = vim.treesitter.get_parser(bufnr, 'lua')
  if not parser then
    return
  end

  local tree = parser:parse()[1]
  if not tree then
    return
  end

  walk(tree:root(), hints, bufnr)
end

local function toggle()
  enabled = not enabled
  refresh(vim.api.nvim_get_current_buf())
  vim.notify('DSL hints ' .. (enabled and 'enabled' or 'disabled'))
end

vim.api.nvim_create_user_command('DslHintsToggle', toggle, {})
vim.keymap.set('n', '<leader>td', toggle, { desc = '[T]oggle [D]SL hints' })

local augroup = vim.api.nvim_create_augroup('dsl-hints', { clear = true })
vim.api.nvim_create_autocmd({ 'BufEnter', 'TextChanged', 'InsertLeave' }, {
  pattern = '*.lua',
  group = augroup,
  callback = function(ev)
    refresh(ev.buf)
  end,
})
